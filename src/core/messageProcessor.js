import LtmService from '../services/LtmService.js';
import { normalizeAiResponse } from '../utils/aiResponseUtils.js';
import logger from '../utils/logger.js';

// Core modules
import { sanitizeMessagesForChat } from './processors/messageSanitizer.js';
import STMManager from './memory/stmManager.js';
import ImageProcessor from './processors/imageProcessor.js';
import DynamicPromptBuilder from './prompt/dynamicPromptBuilder.js';
import MCPToolExecutor from './tools/MCPToolExecutor.js';
import MessageAuthHandler from './processors/messageAuthHandler.js';
import AIAnalysisHandler from './processors/aiAnalysisHandler.js';

// Personality system
import PersonalityOrchestrator from './personality/PersonalityOrchestrator.js';

// Repository imports
import { getUserContext, updateUserContext } from '../repository/contextRepository.js';
import { getUserProfile } from '../repository/userProfileRepository.js';

// Skills imports
import updateUserProfileSummary from '../skills/updateUserProfileSummary.js';

// WhatsApp imports
import simulateTyping from '../whatsapp/simulateTyping.js';

// Config imports
import chatAi from '../config/ai/chat.ai.js';

// Environment config
const groups = JSON.parse(process.env.WHATSAPP_GROUPS) || [];

/**
 * Processador principal de mensagens - Refatorado com Sistema de Personalidade Evolutiva
 * N√∫cleo central da aplica√ß√£o que coordena todo o fluxo de processamento
 */
class MessageProcessor {
  // Vari√°veis de classe para o sistema de personalidade
  static personalityOrchestrator = null;
  static personalityInitialized = false;

  /**
   * Inicializa o sistema de personalidade (lazy loading)
   * @private
   */
  static async _ensurePersonalityInitialized() {
    if (!this.personalityOrchestrator) {
      this.personalityOrchestrator = new PersonalityOrchestrator();
    }
    
    if (!this.personalityInitialized) {
      await this.personalityOrchestrator.initialize();
      this.personalityInitialized = true;
      logger.info('MessageProcessor', 'üé≠ Sistema de personalidade inicializado');
    }
  }
  /**
   * Processa mensagem recebida
   * @param {Object} message - Mensagem recebida
   */
  static async processMessage(message) {
    // Gerar ID √∫nico para esta mensagem
    const messageId = logger.generateMessageId();
    
    const startTime = Date.now();
    logger.start('MessageProcessor', 'Processamento de mensagem iniciado');
    
    try {
      const { data } = message;
      
      // Log da intera√ß√£o inicial
      logger.interaction('MessageProcessor', 'webhook-received', {
        from: data.from,
        messageType: data.messageType || 'text',
        hasImage: !!data.image
      });
      
      // Verificar autoriza√ß√£o da mensagem
      if (!MessageAuthHandler.isMessageAuthorized(data, groups)) {
        logger.debug('MessageProcessor', 'Mensagem n√£o autorizada - ignorando');
        return;
      }

      logger.milestone('MessageProcessor', 'Mensagem autorizada para processamento');
    
      // Inicializar sistema de personalidade
      await this._ensurePersonalityInitialized();
    
      // Feedback imediato: simular digita√ß√£o no in√≠cio
      simulateTyping(data.from, true); // N√£o aguardar - executar em background
    
      // Processar imagens automaticamente se detectadas
      logger.step('MessageProcessor', 'Processando imagens detectadas');
      const { userContent, imageAnalysisResult } = await ImageProcessor.processImage(data);
      const userId = MessageAuthHandler.extractUserId(data.from);
    
      // Carregar dados do usu√°rio
      logger.step('MessageProcessor', 'Carregando contexto e perfil do usu√°rio');
      
      const [
        { messages: rawMessages }, 
        userProfile, 
        ltmContext
      ] = await Promise.all([
        getUserContext(userId),
        getUserProfile(userId),
        LtmService.getRelevantContext(userId, userContent)
      ]);
    
      logger.timing('MessageProcessor', 'Dados do usu√°rio carregados', {
        messagesCount: rawMessages.length,
        hasUserProfile: !!userProfile,
        ltmContextSize: ltmContext?.length || 0
      });
    
      // Sanitizar contexto hist√≥rico
      logger.step('MessageProcessor', 'Sanitizando contexto hist√≥rico');
      let messages = sanitizeMessagesForChat(rawMessages);
      logger.timing('MessageProcessor', 'Contexto hist√≥rico sanitizado', {
        originalCount: rawMessages.length,
        sanitizedCount: messages.length
      });
    
      // Gerenciar STM (Short Term Memory)
      logger.step('MessageProcessor', 'üß† Iniciando gerenciamento STM');
      try {
        messages = await STMManager.manageSTM(messages, userContent, userId, data.from);
        logger.timing('MessageProcessor', 'üß† Gerenciamento STM conclu√≠do', {
          finalMessageCount: messages.length
        });
      } catch (error) {
        logger.critical('MessageProcessor', `Erro no gerenciamento STM: ${error.message}`, {
          stack: error.stack
        });
        throw error;
      }

      // Construir prompt din√¢mico
      logger.step('MessageProcessor', 'üèóÔ∏è Construindo prompt din√¢mico');
      let dynamicPrompt;
      try {
        dynamicPrompt = DynamicPromptBuilder.buildDynamicPrompt(userProfile, ltmContext, imageAnalysisResult);
        logger.timing('MessageProcessor', 'üèóÔ∏è Prompt din√¢mico constru√≠do');
      } catch (error) {
        logger.critical('MessageProcessor', `Erro na constru√ß√£o do prompt: ${error.message}`);
        throw error;
      }

            // Executar an√°lises de IA
      simulateTyping(data.from, true);
      logger.step('MessageProcessor', 'ü§ñ Iniciando an√°lises de IA');
      let currentSentiment, inferredStyle;
      try {
        const aiAnalysis = await AIAnalysisHandler.performAIAnalysis(userContent, userId, userProfile);
        currentSentiment = aiAnalysis.currentSentiment;
        inferredStyle = aiAnalysis.inferredStyle;
        logger.timing('MessageProcessor', 'ü§ñ An√°lises de IA conclu√≠das', {
          sentiment: currentSentiment,
          style: inferredStyle
        });
      } catch (error) {
        logger.error('MessageProcessor', `Erro nas an√°lises de IA: ${error.message}`);
        // Valores padr√£o em caso de erro
        currentSentiment = 'neutro';
        inferredStyle = 'neutral';
      }

      // üé≠ PROCESSAMENTO DA PERSONALIDADE EVOLUTIVA
      logger.step('MessageProcessor', 'üé≠ Processando evolu√ß√£o da personalidade');
      logger.debug('MessageProcessor', 'üé≠ ENTRADA PERSONALIDADE:', {
        userId,
        contentLength: userContent?.length || 0,
        currentSentiment,
        messageType: data.messageType || 'text',
        hasImage: !!data.image,
        conversationLength: messages.length
      });
      
      try {
        const personalityResult = await this.personalityOrchestrator.processPersonalityInteraction(
          userId, 
          userContent, 
          currentSentiment, 
          {
            messageType: data.messageType || 'text',
            hasImage: !!data.image,
            inferredStyle,
            conversationLength: messages.length
          }
        );
        
        logger.debug('MessageProcessor', 'üé≠ RESULTADO PERSONALIDADE:', {
          mood: personalityResult.mood,
          formationLevel: personalityResult.personality_formation,
          evolutionApplied: personalityResult.evolution_applied
        });
        
        logger.timing('MessageProcessor', 'üé≠ Personalidade evolutiva processada');
      } catch (error) {
        logger.error('MessageProcessor', `Erro no processamento da personalidade: ${error.message}`);
        // Continuar o fluxo mesmo com erro na personalidade
      }

      // üèóÔ∏è CONSTRUIR PROMPT EVOLUTIVO (substituindo o prompt din√¢mico b√°sico)
      logger.step('MessageProcessor', 'üèóÔ∏è Construindo prompt evolutivo');
      let personalityMetadata;
      try {
        const situationType = this._determineSituationType(messages, userContent);
        logger.debug('MessageProcessor', 'üèóÔ∏è ENTRADA BUILD PROMPT:', {
          userId,
          hasProfile: !!userProfile,
          ltmContextLength: ltmContext?.length || 0,
          hasImageAnalysis: !!imageAnalysisResult,
          situationType
        });
        
        const promptResult = await this.personalityOrchestrator.buildPersonalityPrompt(
          userId, 
          userProfile, 
          ltmContext, 
          imageAnalysisResult,
          situationType
        );
        dynamicPrompt = promptResult.prompt;
        personalityMetadata = promptResult.personalityMetadata;
        
        logger.debug('MessageProcessor', 'üèóÔ∏è PROMPT RESULT:', {
          promptLength: dynamicPrompt?.content?.length || 0,
          mood: personalityMetadata.mood,
          formationLevel: personalityMetadata.formation_level,
          adaptiveBehaviors: personalityMetadata.adaptive_behaviors?.length || 0
        });
        
        logger.timing('MessageProcessor', 'üèóÔ∏è Prompt evolutivo constru√≠do', {
          mood: personalityMetadata.mood,
          formationLevel: personalityMetadata.formation_level,
          familiarityLevel: personalityMetadata.familiarity_level
        });
      } catch (error) {
        logger.error('MessageProcessor', `Erro na constru√ß√£o do prompt evolutivo: ${error.message}`);
        // Fallback para prompt b√°sico
        dynamicPrompt = DynamicPromptBuilder.buildDynamicPrompt(userProfile, ltmContext, imageAnalysisResult);
        personalityMetadata = { mood: 'neutral', formation_level: 0, familiarity_level: 0 };
      }

      // Preparar mensagens para chat
      logger.step('MessageProcessor', 'üí¨ Preparando mensagens para chat');
      const chatMessages = [dynamicPrompt, ...messages, { role: 'user', content: userContent }];
      const sanitizedChatMessages = sanitizeMessagesForChat(chatMessages);
    
      // Obter ferramentas dispon√≠veis do MCP dinamicamente
      logger.step('MessageProcessor', 'üîß Obtendo ferramentas do MCP dinamicamente');
      const mcpExecutor = new MCPToolExecutor();
      const dynamicTools = await mcpExecutor.getToolsForOpenAI();
      logger.milestone('MessageProcessor', `${dynamicTools.length} ferramentas obtidas do MCP dinamicamente`);
    
      // Gerar resposta principal da IA com ferramentas din√¢micas
      logger.step('MessageProcessor', 'üéØ Gerando resposta principal da IA com ferramentas din√¢micas');
      let response;
      try {
        const aiStartTime = Date.now();
        response = await chatAi(sanitizedChatMessages, dynamicTools);
        const aiEndTime = Date.now();
        
        response = normalizeAiResponse(response);
        
        // Log detalhado da resposta da IA
        logger.aiResponse('MessageProcessor', 'OpenAI', response, {
          requestTime: aiEndTime - aiStartTime,
          messageLength: sanitizedChatMessages.length,
          toolsAvailable: dynamicTools.length
        });
        
        logger.timing('MessageProcessor', 'üéØ Resposta principal gerada', {
          aiTime: `${aiEndTime - aiStartTime}ms`,
          hasContent: !!response.message?.content,
          toolCallsCount: response.message?.tool_calls?.length || 0
        });
      } catch (error) {
        logger.critical('MessageProcessor', `Erro ao gerar resposta principal: ${error.message}`);
        
        // Try to send an error message to the user instead of crashing
        try {
          const mcpExecutor = new MCPToolExecutor();
          await mcpExecutor.executeTools([{
            name: 'send_message',
            arguments: {
              content: `‚ùå Desculpe, ocorreu um erro tempor√°rio ao processar sua mensagem. Tente novamente em alguns segundos.\n\nDetalhes: ${error.message.includes('Rate limit') ? 'Limite de uso da IA atingido temporariamente.' : 'Erro interno do sistema.'}`
            }
          }]);
          logger.milestone('MessageProcessor', 'Mensagem de erro enviada ao usu√°rio');
          return; // Exit gracefully
        } catch (fallbackError) {
          logger.critical('MessageProcessor', `Falha ao enviar mensagem de erro: ${fallbackError.message}`);
        }
        
        throw error; // Only throw if we couldn't send error message to user
      }

      // Atualizar mensagens com intera√ß√£o atual
      logger.step('MessageProcessor', 'üìù Atualizando mensagens com intera√ß√£o atual');
      messages.push({ role: 'user', content: userContent });
      messages.push(response.message);

      // Executar ciclo de ferramentas
      logger.step('MessageProcessor', 'üîß Iniciando ciclo de ferramentas');
      logger.debug('MessageProcessor', `Response tem tool_calls: ${response.message.tool_calls?.length || 0}`);
      await this._executeToolCycle(messages, response, dynamicTools, data, userContent, imageAnalysisResult, mcpExecutor);
      logger.timing('MessageProcessor', 'üîß Ciclo de ferramentas conclu√≠do');

      // Atualiza√ß√µes finais
      logger.step('MessageProcessor', 'üíæ Realizando atualiza√ß√µes finais');
    
      await updateUserContext(userId, { messages });

      // Atualiza√ß√µes ass√≠ncronas em background
      logger.debug('MessageProcessor', 'Iniciando atualiza√ß√µes ass√≠ncronas em background');
    
      // Limitar o texto para LTM a um tamanho razo√°vel (aprox. 6000 tokens = 24000 chars)
      const conversationText = messages.map((m) => m.content).join('\n');
      const limitedText = conversationText.length > 24000 
        ? conversationText.substring(conversationText.length - 24000) 
        : conversationText;
      
      updateUserProfileSummary(userId, messages)
        .catch(err => logger.error('MessageProcessor', `Erro ao atualizar resumo do perfil em background: ${err}`));
        
      logger.timing('MessageProcessor', ' Atualiza√ß√µes conclu√≠das');
      
      logger.end('MessageProcessor', `Processamento da mensagem conclu√≠do - TEMPO TOTAL: ${Date.now() - startTime}ms`);
      
    } catch (error) {
      logger.critical('MessageProcessor', `Erro cr√≠tico no processamento: ${error.message}`, {
        stack: error.stack
      });
      // Tentar enviar uma mensagem de erro para o usu√°rio
      try {
        const { data } = message;
        await simulateTyping(data.from, false);
        
        // Try to use MCP to send error message
        const fallbackMcpExecutor = new MCPToolExecutor();
        await fallbackMcpExecutor.executeTools([{
          name: 'send_message',
          arguments: {
            content: `‚ùå Ocorreu um erro interno. Por favor, tente novamente em alguns minutos.\n\n${error.message.includes('Rate limit') ? 'üïê Sistema temporariamente sobrecarregado.' : '‚ö†Ô∏è Erro no processamento da mensagem.'}`
          }
        }]);
        
        logger.milestone('MessageProcessor', 'Mensagem de erro enviada ao usu√°rio via MCP');
      } catch (fallbackError) {
        logger.critical('MessageProcessor', `Erro no fallback: ${fallbackError.message}`);
        logger.critical('MessageProcessor', 'CR√çTICO: N√£o foi poss√≠vel notificar o usu√°rio sobre o erro');
      }
      
      // Don't re-throw - let the application continue running
      logger.milestone('MessageProcessor', 'Erro tratado - aplica√ß√£o continuar√° executando');
    }
  }

  /**
   * Executa ciclo de ferramentas com limite de tentativas
   * @private
   */
  static async _executeToolCycle(messages, response, tools, data, userContent, imageAnalysisResult, mcpExecutor) {
    logger.debug('MessageProcessor', 'üé¨ === ENTRANDO EM _executeToolCycle ===');
    let toolCycleCount = 0;
    const MAX_TOOL_CYCLES = 3;
    let lastResponse = response.message;
    
    // Rastrear tools executadas para evitar loops
    const executedTools = new Set();
    
    logger.debug('MessageProcessor', `üîß Iniciando ciclo de ferramentas - Response: ${lastResponse.content ? 'com conte√∫do' : 'sem conte√∫do'}, Tool calls: ${lastResponse.tool_calls?.length || 0}`);
    
    while (toolCycleCount < MAX_TOOL_CYCLES) {
      logger.debug('MessageProcessor', `üîÑ Ciclo ${toolCycleCount + 1}/${MAX_TOOL_CYCLES}`);
      
      if ((lastResponse.tool_calls && lastResponse.tool_calls.length > 0) || lastResponse.function_call) {
        logger.debug('MessageProcessor', `üõ†Ô∏è Executando ${lastResponse.tool_calls?.length || 1} ferramenta(s)...`);
        
        // Verificar se tools foram executadas com sucesso (evitar loop infinito apenas para ferramentas bem-sucedidas)
        const toolNames = lastResponse.tool_calls?.map(tc => tc.function.name) || [];
        
        // Verificar se h√° uma gera√ß√£o de imagem bem-sucedida para O MESMO PROMPT
        const hasSuccessfulImageGeneration = messages.slice(-5).some(msg => 
          msg.role === 'tool' && 
          msg.content && 
          msg.content.includes('"success": true') && 
          msg.content.includes('"sent": true') &&
          (msg.content.includes('image_generation') || msg.content.includes('Imagem gerada e enviada'))
        );
        
        // Se h√° image_generation sendo solicitada, verificar se √© o mesmo prompt j√° executado
        const hasRecentImageGeneration = toolNames.includes('image_generation');
        
        if (hasRecentImageGeneration) {
          // Obter o prompt atual da solicita√ß√£o
          const currentImagePrompt = lastResponse.tool_calls
            .filter(tc => tc.function.name === 'image_generation')
            .map(tc => {
              try {
                const args = JSON.parse(tc.function.arguments);
                return args.prompt;
              } catch (e) {
                return null;
              }
            })[0];

          if (currentImagePrompt) {
            // Verificar se h√° m√∫ltiplas tentativas do mesmo prompt neste ciclo (loop imediato)
            const currentCycleImageCalls = lastResponse.tool_calls
              .filter(tc => tc.function.name === 'image_generation')
              .map(tc => {
                try { return JSON.parse(tc.function.arguments).prompt; } 
                catch (e) { return null; }
              })
              .filter(p => p && p === currentImagePrompt);

            const isImmediateLoop = currentCycleImageCalls.length > 1;
            
            // Verificar se o MESMO PROMPT foi solicitado nas √∫ltimas 5 mensagens (loop recente)
            const recentMessages = messages.slice(-5);
            const samePromptInRecentCycle = recentMessages.some(msg => 
              msg.role === 'assistant' && 
              msg.tool_calls && 
              msg.tool_calls.some(tc => {
                if (tc.function.name === 'image_generation') {
                  try {
                    const args = JSON.parse(tc.function.arguments);
                    return args.prompt === currentImagePrompt;
                  } catch (e) {
                    return false;
                  }
                }
                return false;
              })
            );

            if (isImmediateLoop || samePromptInRecentCycle) {
              logger.debug('MessageProcessor', `üñºÔ∏è LOOP imediato detectado - prompt "${currentImagePrompt.substring(0, 50)}..." executado muito recentemente - pulando duplica√ß√£o`);
              // Remover apenas as tool_calls duplicadas de image_generation
              lastResponse.tool_calls = lastResponse.tool_calls.filter(tc => 
                !(tc.function.name === 'image_generation' && 
                  JSON.parse(tc.function.arguments).prompt === currentImagePrompt)
              );
              
              // Se n√£o h√° outras tools para executar, pular este ciclo
              if (lastResponse.tool_calls.length === 0) {
                logger.debug('MessageProcessor', '‚úÖ Loop de image_generation resolvido - finalizando ciclo');
                break;
              }
            } else {
              logger.debug('MessageProcessor', `üñºÔ∏è Nova solicita√ß√£o de imagem detectada, permitindo execu√ß√£o: "${currentImagePrompt.substring(0, 50)}..."`);
            }
          }
        }
        
        // Permitir re-tentativas se:
        // 1. √â o primeiro ciclo (toolCycleCount === 0)
        // 2. H√° novas ferramentas que nunca foram tentadas
        // 3. H√° ferramentas que falharam e podem ser re-tentadas
        const shouldContinueExecution = toolCycleCount === 0 || toolNames.length > 0;
        
        if (!shouldContinueExecution && toolCycleCount > 0) {
          logger.warn('MessageProcessor', 'üîÑ Nenhuma nova ferramenta para executar - encerrando ciclo');
          break;
        }
        
        const updatedMessages = await mcpExecutor.executeTools(
          messages, 
          { message: lastResponse }, 
          tools, 
          data.from, 
          data.id, 
          userContent, 
          data, 
          imageAnalysisResult
        );
        
        // N√£o registrar automaticamente as tools como executadas
        // Permitir que a IA decida se precisa re-tentar ou fazer send_message
        
        logger.debug('MessageProcessor', `üì® Mensagens atualizadas: ${updatedMessages.length} total`);
        
        // DEBUG: Verificar estrutura das mensagens ap√≥s execu√ß√£o das tools
        const lastMessages = updatedMessages.slice(-5);
        logger.debug('MessageProcessor', 'üîç DEBUG - √öltimas 5 mensagens ap√≥s execu√ß√£o das tools:');
        lastMessages.forEach((msg, index) => {
          logger.debug('MessageProcessor', `  ${index}: role=${msg.role}, content="${msg.content?.substring(0, 50) || 'null'}...", tool_calls=${msg.tool_calls?.length || 0}, tool_call_id=${msg.tool_call_id || 'undefined'}`);
        });
        
        // Atualizar refer√™ncia das mensagens
        messages.length = 0;
        messages.push(...updatedMessages);
        
        // Verificar se alguma das tools executadas foi send_message
        const hasSendMessage = lastResponse.tool_calls?.some(tc => tc.function.name === 'send_message');
        
        logger.debug('MessageProcessor', `üîç Verificando send_message: hasSendMessage=${hasSendMessage}`);
        
        if (hasSendMessage) {
          logger.debug('MessageProcessor', '‚úÖ Send_message executado - finalizando ciclo');
          executedTools.add('send_message'); // Registrar apenas send_message como executada
          break;
        } else {
          logger.debug('MessageProcessor', 'üîÑ Tools executadas, fazendo nova chamada √† IA para poss√≠vel send_message');
          
          // Fazer nova chamada √† IA para que possa decidir pr√≥ximos passos
          try {
            logger.debug('MessageProcessor', `üìù Mensagens antes da nova chamada IA: ${messages.length} total`);
            const aiResponse = await chatAi(messages, tools);
            messages.push({
              role: 'assistant',
              content: aiResponse.message.content || '',
              tool_calls: aiResponse.message.tool_calls || []
            });
            
            lastResponse = aiResponse.message;
            logger.debug('MessageProcessor', `ü§ñ Nova resposta da IA com ${lastResponse.tool_calls?.length || 0} tool calls`);
            logger.debug('MessageProcessor', `ü§ñ Conte√∫do da resposta: "${lastResponse.content?.substring(0, 100)}..."`);
            
            // N√£o interromper aqui - deixar que as tools sejam executadas no pr√≥ximo ciclo
          } catch (error) {
            logger.error('MessageProcessor', 'Erro ao fazer nova chamada √† IA:', error);
            break;
          }
        }
      } else if (lastResponse.tool_calls && lastResponse.tool_calls.length > 0) {
        // Fallback: garantir que toda tool_call tenha uma mensagem tool
        logger.debug('MessageProcessor', '‚ö†Ô∏è Fallback: Adicionando respostas para tool_calls √≥rf√£as');
        this._addFallbackToolResponses(messages, lastResponse);
        break;
      } else {
        // Se n√£o h√° tool_calls, encerra ciclo
        logger.debug('MessageProcessor', '‚úÖ Sem tool_calls - encerrando ciclo normalmente');
        break;
      }
      toolCycleCount++;
    }

    logger.debug('MessageProcessor', 'üîç Verificando necessidade de fallback final...');
    // Fallback final se n√£o houve resposta send_message
    await this._handleFinalFallback(messages, data);
  }

  /**
   * Adiciona respostas de fallback para tool_calls √≥rf√£as
   * @private
   */
  static _addFallbackToolResponses(messages, lastResponse) {
    for (const toolCall of lastResponse.tool_calls) {
      const fallbackResponse = {
        role: 'tool',
        tool_call_id: toolCall.id,
        content: 'Erro: ferramenta n√£o encontrada ou falhou ao executar.',
      };
      messages.push(fallbackResponse);
      logger.debug('MessageProcessor', `Fallback: Adicionada resposta de erro para tool_call_id=${toolCall.id}`);
    }
  }

  /**
   * Lida com fallback final quando n√£o h√° send_message
   * @private
   */
  static async _handleFinalFallback(messages, data) {
    const hasSendMessage = messages.some(m => 
      m.role === 'assistant' && 
      m.tool_calls && 
      m.tool_calls.some(tc => tc.function.name === 'send_message')
    );
    
    logger.debug('MessageProcessor', `üîç Verifica√ß√£o send_message: ${hasSendMessage ? 'ENCONTRADO' : 'N√ÉO ENCONTRADO'}`);
    
    if (!hasSendMessage) {
      logger.warn('MessageProcessor', '‚ö†Ô∏è Fallback final: Solicitando √† LLM uma mensagem amig√°vel de erro.');
      
      const sanitizedFallbackHistory = sanitizeMessagesForChat(
        messages.slice(-STMManager.constants.MAX_STM_MESSAGES)
      );
      
      const fallbackPrompt = [
        {
          role: 'system',
          content: 'Voc√™ falhou em obter uma resposta √∫til usando ferramentas. Gere uma mensagem amig√°vel para o usu√°rio explicando que n√£o foi poss√≠vel atender ao pedido, sem citar ferramentas ou detalhes t√©cnicos. Seja educado e sugira alternativas se poss√≠vel.'
        },
        ...sanitizedFallbackHistory
      ];
      
      let fallbackResponse;
      try {
        logger.debug('MessageProcessor', 'ü§ñ Gerando resposta de fallback...');
        fallbackResponse = await chatAi(fallbackPrompt);
      } catch (err) {
        logger.error('MessageProcessor', `‚ùå Erro ao gerar fallback: ${err.message}`);
        fallbackResponse = { message: { content: 'Desculpe, n√£o consegui atender ao seu pedido neste momento.' } };
      }
      
      const fallbackContent = fallbackResponse?.message?.content || 'Desculpe, n√£o consegui atender ao seu pedido neste momento.';
      
      logger.debug('MessageProcessor', `üì® Criando mensagem de fallback: "${fallbackContent.substring(0, 50)}..."`);
      
      const fallbackAssistant = {
        role: 'assistant',
        content: null,
        tool_calls: [
          {
            id: `call_fallback_${Date.now()}`,
            type: 'function',
            function: {
              name: 'send_message',
              arguments: JSON.stringify({ content: fallbackContent })
            }
          }
        ],
        refusal: null,
        annotations: []
      };
      
      messages.push(fallbackAssistant);
      
      const fallbackTool = {
        role: 'tool',
        tool_call_id: fallbackAssistant.tool_calls[0].id,
        content: `Mensagem enviada ao usu√°rio: "${fallbackContent}"`
      };
      
      messages.push(fallbackTool);
      logger.info('MessageProcessor', '‚úÖ Fallback final: Mensagem de erro amig√°vel enviada ao usu√°rio.');
    } else {
      logger.debug('MessageProcessor', '‚úÖ Send_message encontrado - n√£o precisa de fallback');
    }
  }

  /**
   * Determina o tipo de situa√ß√£o para personaliza√ß√£o contextual
   * @private
   */
  static _determineSituationType(messages, userContent) {
    // Primeira intera√ß√£o
    if (messages.length === 0) {
      return 'first_interaction';
    }

    // Tarefa criativa
    const creativeKeywords = ['criar', 'gerar', 'desenhar', 'imagem', 'arte', 'criativo', 'inventar'];
    if (creativeKeywords.some(keyword => userContent.toLowerCase().includes(keyword))) {
      return 'creative_task';
    }

    // Suporte emocional
    const emotionalKeywords = ['triste', 'feliz', 'ansioso', 'preocupado', 'deprimido', 'estressado', 'ajuda', 'como voc√™ se sente'];
    if (emotionalKeywords.some(keyword => userContent.toLowerCase().includes(keyword))) {
      return 'emotional_support';
    }

    // Recupera√ß√£o de erro
    const errorKeywords = ['erro', 'problema', 'n√£o funciona', 'bug', 'falha', 'ajuda urgente'];
    if (errorKeywords.some(keyword => userContent.toLowerCase().includes(keyword))) {
      return 'error_recovery';
    }

    return null; // Situa√ß√£o normal
  }
}

// Exportar fun√ß√£o compat√≠vel com a API existente
export default async function processMessage(message) {
  return MessageProcessor.processMessage(message);
}
